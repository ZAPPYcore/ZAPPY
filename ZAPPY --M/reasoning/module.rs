use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

/// Priority tiers for reasoning directives.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum DirectivePriority {
    /// Low urgency.
    Low,
    /// Default priority.
    Medium,
    /// Highest priority requiring immediate reasoning.
    High,
}

impl DirectivePriority {
    /// Converts to numeric score.
    #[must_use]
    pub fn score(self) -> u8 {
        match self {
            Self::Low => 35,
            Self::Medium => 65,
            Self::High => 90,
        }
    }
}

/// Directive describing the reasoning goal.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReasoningDirective {
    /// Directive id.
    pub id: Uuid,
    /// Natural language prompt.
    pub prompt: String,
    /// Priority.
    pub priority: DirectivePriority,
    /// Optional domain hints.
    pub domains: Vec<String>,
}

impl ReasoningDirective {
    /// Creates a new directive.
    #[must_use]
    pub fn new(prompt: impl Into<String>, priority: DirectivePriority) -> Self {
        Self {
            id: Uuid::new_v4(),
            prompt: prompt.into(),
            priority,
            domains: Vec::new(),
        }
    }
}

/// Packet describing incoming signals.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SignalPacket {
    /// Unique signal id.
    pub id: Uuid,
    /// Narrative summary.
    pub narrative: String,
    /// Structured payload.
    pub payload: Value,
    /// Timestamp.
    pub observed_at: DateTime<Utc>,
}

impl SignalPacket {
    /// Creates a signal packet.
    #[must_use]
    pub fn new(narrative: impl Into<String>, payload: serde_json::Value) -> Self {
        Self {
            id: Uuid::new_v4(),
            narrative: narrative.into(),
            payload,
            observed_at: Utc::now(),
        }
    }
}

/// Hypothesis generated by the reasoning engine.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReasoningHypothesis {
    /// Hypothesis id.
    pub id: Uuid,
    /// Summary text.
    pub summary: String,
    /// Confidence 0-1.
    pub confidence: f32,
    /// Supporting signals ids.
    pub supporting_signals: Vec<Uuid>,
}

impl ReasoningHypothesis {
    /// Returns true if it meets the acceptance threshold.
    #[must_use]
    pub fn is_viable(&self) -> bool {
        self.confidence >= 0.55
    }
}

/// Final verdict produced after multi-domain review.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Verdict {
    /// Directive id.
    pub directive_id: Uuid,
    /// Selected hypothesis (if any).
    pub hypothesis: Option<ReasoningHypothesis>,
    /// Review notes.
    pub notes: String,
    /// Decision timestamp.
    pub decided_at: DateTime<Utc>,
}
